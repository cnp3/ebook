# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019 Olivier Bonaventure
# This file is distributed under the same license as the Computer networking
# : Principles, Protocols and Practice package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Computer networking : Principles, Protocols and Practice "
"3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-09 12:39+0000\n"
"PO-Revision-Date: 2021-05-09 09:45+0000\n"
"Last-Translator: Philippe D <philippe.dan@student.uclouvain.be>\n"
"Language-Team: French <http://weblate.info.ucl.ac.be/projects/cnp3-ebook/"
"protocolsdns/fr/>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n > 1;\n"
"X-Generator: Weblate 3.9.1\n"
"Generated-By: Babel 2.7.0\n"

#: ../../protocols/dns.rst:7
msgid "The Domain Name System"
msgstr "Le système de nom de domaine (DNS)"

#: ../../protocols/dns.rst:9
msgid ""
"We have already explained the main principles that underlie the "
"utilization of names on the Internet and their mapping to addresses."
msgstr ""
"Nous avons déjà expliqué les grands principes qui régissent l'utilisation "
"des noms sur Internet et leur correspondance avec les adresses."

#: ../../protocols/dns.rst:14
msgid ""
"The last component of the Domain Name System is the DNS protocol. The DNS"
" protocol runs above both the datagram and the bytestream services. In "
"practice, the datagram service is used when short queries and responses "
"are exchanged, and the bytestream service is used when longer responses "
"are expected. In this section, we focus on the utilization of the DNS "
"protocol above the datagram service."
msgstr ""
"Le dernier composant du système de noms de domaine est le protocole DNS. Le "
"protocole DNS fonctionne au-dessus des services datagram et bytestream. En "
"pratique, le service de datagramme est utilisé lorsque des requêtes et des "
"réponses courtes sont échangées, et le service bytestream est utilisé "
"lorsque des réponses plus longues sont attendues. Dans cette section, nous "
"nous concentrons sur l'utilisation du protocole DNS au-dessus du service de "
"datagram."

#: ../../protocols/dns.rst:18
msgid ""
"DNS messages are composed of five parts that are named sections in "
":rfc:`1035`. The first three sections are mandatory and the last two "
"sections are optional. The first section of a DNS message is its "
"`Header`. It contains information about the type of message and the "
"content of the other sections. The second section contains the `Question`"
" sent to the nameserver or resolver. The third section contains the "
"`Answer` to the `Question`. When a client sends a DNS query, the `Answer`"
" section is empty. The fourth section, named `Authority`, contains "
"information about the servers that can provide an authoritative answer if"
" required. The last section contains additional information that is "
"supplied by the resolver or nameserver but was not requested in the "
"question."
msgstr ""
"Les messages DNS sont composés de cinq parties qui sont appelées \"sections\""
" dans :rfc:`1035`. Les trois premières sections sont obligatoires et les "
"deux dernières sont facultatives. La première section d'un message DNS est "
"son `Header`. Elle contient des informations sur le type de message et le "
"contenu des autres sections. La deuxième section contient la `Question` "
"envoyée au serveur de noms ou au résolveur. La troisième section contient la "
"\"réponse\" à la \"question\". Lorsqu'un client envoie une requête DNS, la "
"section `Réponse` est vide. La quatrième section, appelée `Authority`, "
"contient des informations sur les serveurs qui peuvent fournir une réponse "
"faisant autorité si nécessaire. La dernière section contient des "
"informations supplémentaires qui sont fournies par le résolveur ou le "
"serveur de noms mais qui n'ont pas été demandées dans la question."

#: ../../protocols/dns.rst:20
msgid ""
"The header of DNS messages is composed of 12 bytes and its structure is "
"shown in the figure below."
msgstr ""
"L'en-tête des messages DNS est composé de 12 octets et sa structure est "
"présentée dans la figure ci-dessous."

#: ../../protocols/dns.rst:26
msgid "The DNS header"
msgstr "L'en-tête DNS"

#: ../../protocols/dns.rst:28
msgid ""
"The `Transaction ID` (transaction identifier) is a 16-bits random value "
"chosen by the client. When a client sends a question to a DNS server, it "
"remembers the question and its identifier. When a server returns an "
"answer, it returns in the `Transaction ID` field the identifier chosen by"
" the client. Thanks to this identifier, the client can match the received"
" answer with the question that it sent."
msgstr ""
"Le `Transaction ID` (identifiant de transaction) est une valeur aléatoire de "
"16 bits choisie par le client. Lorsqu'un client envoie une question à un "
"serveur DNS, celui-ci se souvient de la question et de son identifiant. "
"Lorsqu'un serveur retourne une réponse, il renvoie dans le champ `"
"Transaction ID` l'identifiant choisi par le client. Grâce à cet identifiant, "
"le client peut faire correspondre la réponse reçue avec la question qu'il a "
"envoyée."

#: ../../protocols/dns.rst:34
msgid ""
"The DNS header contains a series of flags. The `QR` flag is used to "
"distinguish between queries and responses. It is set to `0` in DNS "
"queries and `1` in DNS answers. The `Opcode` is used to specify the type "
"of query. For instance, a :term:`standard query` is when a client sends a"
" `name` and the server returns the corresponding `data`. An update "
"request is when the client sends a `name` and new `data` and the server "
"then updates its database."
msgstr ""
"L'en-tête DNS contient une série de drapeaux. Le drapeau `QR` est utilisé "
"pour distinguer les requêtes des réponses. Il prend la valeur `0` dans les "
"requêtes DNS et `1` dans les réponses DNS. Le `Opcode` est utilisé pour "
"spécifier le type de requête. Par exemple, une :term:`requête standard`, "
"c'est quand un client envoie un `nom` et que le serveur retourne les "
"`données` correspondantes. Une requête de mise à jour, c'est lorsque le "
"client envoie un `name` et de nouvelles `data` et que le serveur met alors à "
"jour sa base de données."

#: ../../protocols/dns.rst:36
msgid ""
"The `AA` bit is set when the server that sent the response has "
"`authority` for the domain name found in the question section. In the "
"original DNS deployments, two types of servers were considered : "
"`authoritative` servers and `non-authoritative` servers. The "
"`authoritative` servers are managed by the system administrators "
"responsible for a given domain. They always store the most recent "
"information about a domain. `Non-authoritative` servers are servers or "
"resolvers that store DNS information about external domains without being"
" managed by the owners of a domain. They may thus provide answers that "
"are out of date. From a security point of view, the `authoritative` bit "
"is not an absolute indication about the validity of an answer. Securing "
"the Domain Name System is a complex problem that was only addressed "
"satisfactorily recently by the utilization of cryptographic signatures in"
" the DNSSEC extensions to DNS described in :rfc:`4033`. These extensions "
"are discussed in chapter XX."
msgstr ""
"Le bit `AA` est activé lorsque le serveur qui a envoyé la réponse a "
"`autorité` pour le nom de domaine trouvé dans la section question. Dans les "
"déploiements DNS originaux, deux types de serveurs étaient considérés : les "
"serveurs `autoritaires` et les serveurs `non-autoritaires`. Les serveurs "
"`authoritative` sont gérés par les administrateurs système responsables d'un "
"domaine donné. Ils stockent toujours les informations les plus récentes sur "
"un domaine. Les serveurs `non-autoritaires` sont des serveurs ou des "
"résolveurs qui stockent des informations DNS sur des domaines externes sans "
"être gérés par les propriétaires d'un domaine. Ils peuvent donc fournir des "
"réponses qui ne sont pas à jour. Du point de vue de la sécurité, le bit \""
"authoritative\" n'est pas une indication absolue de la validité d'une "
"réponse. La sécurisation du système de noms de domaine est un problème "
"complexe qui n'a été abordé de manière satisfaisante que récemment par "
"l'utilisation de signatures cryptographiques dans les extensions DNSSEC du "
"DNS décrites dans le document :rfc:`4033`. Ces extensions sont abordées au "
"chapitre XX."

#: ../../protocols/dns.rst:40
msgid ""
"The `RD` (recursion desired) bit is set by a client when it sends a query"
" to a resolver. Such a query is said to be `recursive` because the "
"resolver will recursively traverse the DNS hierarchy to retrieve the "
"answer on behalf of the client. In the past, all resolvers were "
"configured to perform recursive queries on behalf of any Internet host. "
"However, this exposes the resolvers to several security risks. The "
"simplest one is that the resolver could become overloaded by having too "
"many recursive queries to process. Most resolvers [#f8888]_ only allow "
"recursive queries from clients belonging to their company or network and "
"discard all other recursive queries. The `RA` bit indicates whether the "
"server supports recursion. The `RCODE` is used to distinguish between "
"different types of errors. See :rfc:`1035` for additional details. The "
"last four fields indicate the size of the `Question`, `Answer`, "
"`Authority` and `Additional` sections of the DNS message."
msgstr ""
"Le bit `RD` (recursion desired) est activé par un client lorsqu'il envoie "
"une requête à un résolveur. Une telle requête est dite \"récursive\" parce "
"que le résolveur va parcourir récursivement la hiérarchie DNS pour trouver "
"la réponse au nom du client. Dans le passé, tous les résolveurs étaient "
"configurés pour effectuer des requêtes récursives pour le compte de "
"n'importe quel hôte Internet. Cependant, cela expose les résolveurs à "
"plusieurs risques de sécurité. Le plus simple est que le résolveur peut être "
"surchargé par un trop grand nombre de requêtes récursives à traiter. La "
"plupart des résolveurs [#f8888]_ n'autorisent que les requêtes récursives "
"des clients appartenant à leur société ou à leur réseau et rejettent toutes "
"les autres requêtes récursives. Le bit `RA` indique si le serveur supporte "
"la récursivité. Le `RCODE` est utilisé pour distinguer les différents types "
"d'erreurs. Voir :rfc:`1035` pour plus de détails. Les quatre derniers champs "
"indiquent la taille des sections `Question`, `Answer`, `Authority` et "
"`Additional` du message DNS."

#: ../../protocols/dns.rst:42
msgid ""
"The last four sections of the DNS message contain `Resource Records` "
"(RR).  All RRs have the same top level format shown in the figure below."
msgstr ""
"Les quatre dernières sections du message DNS contiennent les `Resource "
"Records` (RR).  Tous les RR ont le même format de haut niveau, comme le "
"montre la figure ci-dessous."

#: ../../protocols/dns.rst:48
msgid "DNS Resource Records"
msgstr "DNS Resource Records"

#: ../../protocols/dns.rst:50
msgid ""
"In a `Resource Record` (`RR`), the `Name` indicates the name of the node "
"to which this resource record pertains. The two bytes `Type` field "
"indicates the type of resource record. The `Class` field was used to "
"support the utilization of the DNS in other environments than the "
"Internet. The `IN` `Class` refers to Internet names."
msgstr ""
"Dans un `Resource Record` (`RR`), le `Name` indique le nom du noeud auquel "
"cet enregistrement de ressource se rapporte. Le champ `Type` de deux octets "
"indique le type d'enregistrement de ressource. Le champ `Class` a été "
"utilisé pour prendre en charge l'utilisation du DNS dans des environnements "
"autres qu'Internet. Le champ `IN` `Class` fait référence aux noms Internet."

#: ../../protocols/dns.rst:52
msgid ""
"The `TTL` field indicates the lifetime of the `Resource Record` in "
"seconds. This field is set by the server that returns an answer and "
"indicates for how long a client or a resolver can store the `Resource "
"Record` inside its cache. A long `TTL` indicates a stable `RR`. Some "
"companies use short `TTL` values for mobile hosts and also for popular "
"servers. For example, a web hosting company that wants to spread the load"
" over a pool of hundred servers can configure its nameservers to return "
"different answers to different clients. If each answer has a small `TTL`,"
" the clients will be forced to send DNS queries regularly. The nameserver"
" will reply to these queries by supplying the address of the less loaded "
"server."
msgstr ""
"Le champ `TTL` indique la durée de vie de la `Resource Record` en secondes. "
"Ce champ est défini par le serveur qui renvoie une réponse et indique "
"pendant combien de temps un client ou un résolveur peut stocker le `Resource "
"Record` dans son cache. Un `TTL` long indique un `RR` stable. Certaines "
"entreprises utilisent des valeurs `TTL` courtes pour les hôtes mobiles et "
"aussi pour les serveurs populaires. Par exemple, une société d'hébergement "
"web qui veut répartir la charge sur un pool de cent serveurs peut configurer "
"ses serveurs de noms pour qu'ils renvoient des réponses différentes à des "
"clients différents. Si chaque réponse a une petite `TTL`, les clients seront "
"obligés d'envoyer régulièrement des requêtes DNS. Le serveur de noms "
"répondra à ces requêtes en fournissant l'adresse du serveur le moins chargé."

#: ../../protocols/dns.rst:54
msgid ""
"The `RDLength` field is the length of the `RData` field that contains the"
" information of the type specified in the `Type` field."
msgstr ""
"Le champ `RDLength` est la longueur du champ `RData` qui contient les "
"informations du type spécifié dans le champ `Type`."

#: ../../protocols/dns.rst:56
msgid ""
"Several types of DNS RR are used in practice. The `A` type is used to "
"encode the IPv4 address that corresponds to the specified name. The "
"`AAAA` type is used to encode the IPv6 address that corresponds to the "
"specified name. A `NS` record contains the name of the DNS server that is"
" responsible for a given domain. For example, a query for the `AAAA` "
"record associated to the `www.ietf.org` name returns the following "
"answer."
msgstr ""
"Plusieurs types de DNS RR sont utilisés dans la pratique. Le type `A` est "
"utilisé pour encoder l'adresse IPv4 qui correspond au nom spécifié. Le type "
"`AAAA` est utilisé pour encoder l'adresse IPv6 qui correspond au nom "
"spécifié. Un enregistrement `NS` contient le nom du serveur DNS qui est "
"responsable d'un domaine donné. Par exemple, une requête pour "
"l'enregistrement `AAAA` associé au nom `www.ietf.org` renvoie la réponse "
"suivante."

#: ../../protocols/dns.rst:61
msgid "Query for the `AAAA` record of `www.ietf.org`"
msgstr "Requête pour l'enregistrement `AAAA` de `www.ietf.org`"

#: ../../protocols/dns.rst:63
msgid ""
"This answer contains several pieces of information. First, the name "
"`www.ietf.org` is associated to IP address `2001:1890:123a::1:1e`. "
"Second, the `ietf.org` domain is managed by six different nameservers. "
"Five of these nameservers are reachable via IPv4 and IPv6."
msgstr ""
"Cette réponse contient plusieurs informations. Premièrement, le nom "
"`www.ietf.org` est associé à l'adresse IP `2001:1890:123a::1:1e`. "
"Deuxièmement, le domaine `ietf.org` est géré par six serveurs de noms "
"différents. Cinq de ces serveurs de noms sont joignables via IPv4 et IPv6."

#: ../../protocols/dns.rst:65
msgid ""
"`CNAME` (or canonical names) are used to define aliases. For example "
"`www.example.com` could be a `CNAME` for `pc12.example.com` that is the "
"actual name of the server on which the web server for `www.example.com` "
"runs."
msgstr ""
"Les `CNAME` (ou noms canoniques) sont utilisés pour définir des alias. Par "
"exemple, `www.example.com` pourrait être un `CNAME` pour `pc12.example.com` "
"qui est le nom réel du serveur sur lequel tourne le serveur web de "
"`www.example.com`."

#: ../../protocols/dns.rst:67
msgid "Reverse DNS"
msgstr "Reverse DNS"

#: ../../protocols/dns.rst:69
msgid ""
"The DNS is mainly used to find the address that corresponds to a given "
"name. However, it is sometimes useful to obtain the name that corresponds"
" to an IP address. This done by using the `PTR` (`pointer`) `RR`. The "
"`RData` part of a `PTR` `RR` contains the name while the `Name` part of "
"the `RR` contains the IP address encoded in the `in-addr.arpa` domain. "
"IPv4 addresses are encoded in the `in-addr.arpa` by reversing the four "
"digits that compose the dotted decimal representation of the address. For"
" example, consider IPv4 address `192.0.2.11`. The hostname associated to "
"this address can be found by requesting the `PTR`  `RR` that corresponds "
"to `11.2.0.192.in-addr.arpa`. A similar solution is used to support IPv6 "
"addresses :rfc:`3596`, but slightly more complex given the length of the "
"IPv6 addresses. For example, consider IPv6 address "
"`2001:1890:123a::1:1e`. To obtain the name that corresponds to this "
"address, we need first to convert it in a reverse dotted decimal notation"
" : `e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2`. In "
"this notation, each character between dots corresponds to one nibble, "
"i.e. four bits. The low-order byte (`e`) appears first and the high order"
" (`2`) last. To obtain the name that corresponds to this address, one "
"needs to append the `ip6.arpa` domain name and query for "
"`e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.ip6.arpa`."
" In practice, tools and libraries do the conversion automatically and the"
" user does not need to worry about it."
msgstr ""
"Le DNS est principalement utilisé pour trouver l'adresse qui correspond à un "
"nom donné. Cependant, il est parfois utile d'obtenir le nom qui correspond à "
"une adresse IP. Pour ce faire, on utilise le `PTR` (`pointer`) `RR`. La "
"partie `RData` d'un `PTR` `RR` contient le nom tandis que la partie `Name` "
"du `RR` contient l'adresse IP encodée dans le domaine `in-addr.arpa`. Les "
"adresses IPv4 sont codées dans le domaine `in-addr.arpa` en inversant les "
"quatre chiffres qui composent la représentation décimale en pointillés de "
"l'adresse. Par exemple, prenons l'adresse IPv4 `192.0.2.11`. Le nom d'hôte "
"associé à cette adresse peut être trouvé en demandant le `PTR` `RR` qui "
"correspond à `11.2.0.192.in-addr.arpa`. Une solution similaire est utilisée "
"pour supporter les adresses IPv6 :rfc:`3596`, mais légèrement plus complexe "
"étant donné la longueur des adresses IPv6. Par exemple, considérons "
"l'adresse IPv6 `2001:1890:123a::1:1e`. Pour obtenir le nom qui correspond à "
"cette adresse, il faut d'abord la convertir dans une notation décimale "
"pointillée inverse : "
"`e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2`. Dans cette "
"notation, chaque caractère entre les points correspond à un nibble, c'est-à-"
"dire à quatre bits. L'octet de poids faible (`e`) apparaît en premier et "
"celui de poids fort (`2`) en dernier. Pour obtenir le nom correspondant à "
"cette adresse, il faut ajouter le nom de domaine `ip6.arpa` et rechercher "
"`e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.1.0.0.2.ip6.arpa`. En "
"pratique, les outils et les bibliothèques font la conversion automatiquement "
"et l'utilisateur n'a pas à s'en soucier."

#: ../../protocols/dns.rst:72
msgid ""
"An important point to note regarding the Domain Name System it is "
"extensible. Thanks to the `Type` and `RDLength` fields, the format of the"
" Resource Records can easily be extended. Furthermore, a DNS "
"implementation that receives a new Resource Record that it does not "
"understand can ignore the record while still being able to process the "
"other parts of the message. This allows, for example, a DNS server that "
"only supports IPv6 can safely ignore the IPv4 addresses listed in the DNS"
" reply for `www.ietf.org` while still being able to correctly parse the "
"Resource Records that it understands. This allowed the Domain Name System"
" to evolve over the years while still preserving the backward "
"compatibility with already deployed DNS implementations."
msgstr ""
"Un point important à noter concernant le système de noms de domaine : il est "
"extensible. Grâce aux champs `Type` et `RDLength`, le format des "
"enregistrements de ressources peut facilement être étendu. De plus, une "
"implémentation DNS qui reçoit un nouvel enregistrement de ressources qu'elle "
"ne comprend pas peut l'ignorer tout en étant capable de traiter les autres "
"parties du message. Cela permet, par exemple, à un serveur DNS qui ne prend "
"en charge que l'IPv6 d'ignorer sans risque les adresses IPv4 énumérées dans "
"la réponse DNS pour `www.ietf.org` tout en étant capable d'analyser "
"correctement les enregistrements de ressources qu'il comprend. Cela a permis "
"au système de noms de domaine d'évoluer au fil des ans tout en préservant la "
"rétrocompatibilité avec les implémentations DNS déjà déployées."

#: ../../protocols/dns.rst:80
msgid "Footnotes"
msgstr "Notes de bas de page"

#: ../../protocols/dns.rst:81
msgid ""
"Some DNS resolvers allow any host to send queries. Google operates a "
"`public DNS resolver <https://developers.google.com/speed/public-"
"dns/docs/using>`_ at addresses `2001:4860:4860::8888` and "
"`2001:4860:4860::8844`. Other companies provide similar services."
msgstr ""
"Certains résolveurs DNS permettent à tout hôte d'envoyer des requêtes. "
"Google exploite un `résolveur DNS public <https://developers.google.com/"
"speed/public-dns/docs/using>`_ aux adresses `2001:4860:4860::8888` et "
"`2001:4860:4860::8844`. D'autres sociétés fournissent des services "
"similaires."
